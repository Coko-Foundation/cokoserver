scalar DateTime

# find a better place to inject that
input PageInput {
  pageSize: Int!
  page: Int!
}

"A user in the system"
type User {
  "The user's id"
  id: ID!
  "When the user object was created"
  created: DateTime!
  "When the user object was last updated"
  updated: DateTime!
  """
  The user's username. This (and by extension `displayName`) is nullable for
  cases where the user has not created the account themselves, eg. when
  inviting a new user but they haven't accepted the invitation yet.
  """
  username: String
  "The user's surname"
  surname: String
  "The user's given name(s)"
  givenNames: String
  """
  The user's display name. It can be set explicitly, but will fall back to a
  combination of given names and surname, which will fall back to the username.
  """
  displayName: String
  "Whether the user has agreed to the terms and conditions"
  agreedTc: Boolean!
  "Whether the user is active (ie. that an admin or similar has not deactivated their account)"
  isActive: Boolean!
  "A list of identities related to the user"
  identities: [Identity!]!
  "The user's default identity"
  defaultIdentity: Identity!
  "The user's pre-name title (eg. Dr. John Green)"
  titlePre: String
  "The user's post-name title (eg. John Green MD.)"
  titlePost: String
  "A list of teams that the user belongs to"
  teams: [Team!]!
}

"A list of users"
type Users {
  "The list of users"
  result: [User!]!
  "The total count of users"
  totalCount: Int!
}

type LoginResult {
  user: User!
  token: String!
}

input SignUpInput {
  username: String
  email: String!
  password: String!
  givenNames: String!
  surname: String!
  agreedTc: Boolean!
  titlePre: String
  titlePost: String
}

input LoginInput {
  email: String
  username: String
  password: String!
}

input UpdateUserInput {
  email: String
  username: String
  surname: String
  givenNames: String
  agreedTc: Boolean
  titlePre: String
  titlePost: String
}

input UpdatePasswordInput {
  id: ID!
  currentPassword: String!
  newPassword: String!
}

input UserFilter {
  isActive: Boolean
}

extend type Query {
  "Returns a user by id"
  user(id: ID!): User!
  "Returns a list of users"
  users(filter: UserFilter, options: PageInput): Users!
  "Returns the currently logged in user"
  currentUser: User
}

extend type Mutation {
  activateUser(id: ID!): User!
  activateUsers(ids: [ID!]!): [User!]!
  deleteUser(id: ID!): ID!
  deleteUsers(ids: [ID!]!): [ID!]!
  deactivateUser(id: ID!): User!
  deactivateUsers(ids: [ID!]!): [User!]!
  updateUser(id: ID, input: UpdateUserInput!): User!
  login(input: LoginInput!): LoginResult!
  signUp(input: SignUpInput!): ID!
  setDefaultIdentity(userId: ID!, identityId: ID!): User!
  verifyEmail(token: String!): Boolean!
  resendVerificationEmail(token: String!): Boolean!
  resendVerificationEmailFromLogin(
    username: String!
    password: String!
  ): Boolean!
  resendVerificationEmailAfterLogin: Boolean!
  updatePassword(input: UpdatePasswordInput!): Boolean!
  sendPasswordResetEmail(email: String!): Boolean!
  resetPassword(token: String!, password: String!): Boolean!
}

extend type Subscription {
  userUpdated(userId: ID!): User!
}
