"The `DateTime` scalar type represents a timestamp."
scalar DateTime

"Options for pagination"
input PageInput {
  "How many items should be on each page"
  pageSize: Int!
  "Which page (eg. page 2)"
  page: Int!
}

"A user in the system"
type User {
  "The user's id"
  id: ID!
  "When the user object was created"
  created: DateTime!
  "When the user object was last updated"
  updated: DateTime!
  """
  The user's username. This (and by extension `displayName`) is nullable for
  cases where the user has not created the account themselves, eg. when
  inviting a new user but they haven't accepted the invitation yet.
  """
  username: String
  "The user's surname"
  surname: String
  "The user's given name(s)"
  givenNames: String
  """
  The user's display name. It can be set explicitly, but will fall back to a
  combination of given names and surname, which will fall back to the username.
  """
  displayName: String
  "Whether the user has agreed to the terms and conditions"
  agreedTc: Boolean!
  "Whether the user is active (ie. that an admin or similar has not deactivated their account)"
  isActive: Boolean!
  "A list of identities related to the user"
  identities: [Identity!]!
  "The user's default identity"
  defaultIdentity: Identity!
  "The user's pre-name title (eg. Dr. John Green)"
  titlePre: String
  "The user's post-name title (eg. John Green MD.)"
  titlePost: String
  "A list of teams that the user belongs to"
  teams: [Team!]!
}

"A list of users"
type Users {
  "The list of users"
  result: [User!]!
  "The total count of users"
  totalCount: Int!
}

"Value returned from logging in"
type LoginResult {
  "The user that was just logged in"
  user: User!
  "The user's login jwt token"
  token: String!
}

"Data for signing a user up"
input SignUpInput {
  "The user's username"
  username: String
  "The user's email"
  email: String!
  "The user's password"
  password: String!
  "The user's first/given name(s)"
  givenNames: String!
  "The user's last/surname"
  surname: String!
  "Whether the user has agreed to the terms and conditions"
  agreedTc: Boolean!
  "A prefix to the user's name"
  titlePre: String
  "A suffix to the user's name"
  titlePost: String
}

"Data for logging a user in"
input LoginInput {
  "The user's email"
  email: String
  "The user's username"
  username: String
  "The user's password"
  password: String!
}

"Data for updating a user"
input UpdateUserInput {
  "The user's email"
  email: String
  "The user's username"
  username: String
  "The user's last/surname"
  surname: String
  "The user's first/given name(s)"
  givenNames: String
  "Whether the user has agreed to the terms and conditions"
  agreedTc: Boolean
  "The user's name prefix"
  titlePre: String
  "The user's name suffix"
  titlePost: String
}

"Data for updating a user's password"
input UpdatePasswordInput {
  "The user's id"
  id: ID!
  "The user's current password"
  currentPassword: String!
  "The user's new password"
  newPassword: String!
}

"Filter options for users"
input UserFilter {
  "Whether the user is active or not"
  isActive: Boolean
}

extend type Query {
  "Returns a user by id"
  user(id: ID!): User!
  "Returns a list of users"
  users(filter: UserFilter, pagination: PageInput): Users!
  "Returns the currently logged in user"
  currentUser: User
}

extend type Mutation {
  "Activate a user account"
  activateUser(id: ID!): User!
  "Activate multiple user accounts"
  activateUsers(ids: [ID!]!): [User!]!
  "Deactivate a user account"
  deactivateUser(id: ID!): User!
  "Deativate multiple user accounts"
  deactivateUsers(ids: [ID!]!): [User!]!

  "Delete one user"
  deleteUser(id: ID!): ID!
  "Delete multiple users"
  deleteUsers(ids: [ID!]!): Int!
  "Set a user identity as default"
  setDefaultIdentity(userId: ID!, identityId: ID!): User!
  "Update a user's password"
  updatePassword(input: UpdatePasswordInput!): Boolean!
  "Update one user"
  updateUser(id: ID!, input: UpdateUserInput!): User!

  "Login"
  login(input: LoginInput!): LoginResult!
  "Sign up"
  signUp(input: SignUpInput!): ID!
  "Resends the verification email. Meant for use with a token generated by the `verifyEmail` mutation, when the user is not logged in. (eg. if they click on the link with the token but it has expired)"
  resendVerificationEmail(token: String!): Boolean!
  "Resends the verification email. Use this if the user is logged in (but eg. blocked from moving forward until the email is verified)."
  resendVerificationEmailAfterLogin: Boolean!
  "Resets the user's password. Token must have been generated from the `sendPasswordResetEmail` resolver. Password is the new password."
  resetPassword(token: String!, password: String!): Boolean!
  "Sends an email with a password reset link"
  sendPasswordResetEmail(email: String!): Boolean!
  "Sends an email with a token, so that the email can be verified"
  verifyEmail(token: String!): Boolean!
}

extend type Subscription {
  "Trigger an update for a specific user by id"
  userUpdated(userId: ID!): User!
}
