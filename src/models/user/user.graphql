scalar DateTime

# find a better place to inject that
input PageInput {
  pageSize: Int!
  page: Int!
}

"A user in the system"
type User {
  "The user's id"
  id: ID!
  "When the user object was created"
  created: DateTime!
  "When the user object was last updated"
  updated: DateTime!
  """
  The user's username. This (and by extension `displayName`) is nullable for
  cases where the user has not created the account themselves, eg. when
  inviting a new user but they haven't accepted the invitation yet.
  """
  username: String
  "The user's surname"
  surname: String
  "The user's given name(s)"
  givenNames: String
  """
  The user's display name. It can be set explicitly, but will fall back to a
  combination of given names and surname, which will fall back to the username.
  """
  displayName: String
  "Whether the user has agreed to the terms and conditions"
  agreedTc: Boolean!
  "Whether the user is active (ie. that an admin or similar has not deactivated their account)"
  isActive: Boolean!
  "A list of identities related to the user"
  identities: [Identity!]!
  "The user's default identity"
  defaultIdentity: Identity!
  "The user's pre-name title (eg. Dr. John Green)"
  titlePre: String
  "The user's post-name title (eg. John Green MD.)"
  titlePost: String
  "A list of teams that the user belongs to"
  teams: [Team!]!
}

"A list of users"
type Users {
  "The list of users"
  result: [User!]!
  "The total count of users"
  totalCount: Int!
}

type LoginResult {
  user: User!
  token: String!
}

input SignUpInput {
  username: String
  email: String!
  password: String!
  givenNames: String!
  surname: String!
  agreedTc: Boolean!
  titlePre: String
  titlePost: String
}

input LoginInput {
  email: String
  username: String
  password: String!
}

input UpdateUserInput {
  email: String
  username: String
  surname: String
  givenNames: String
  agreedTc: Boolean
  titlePre: String
  titlePost: String
}

input UpdatePasswordInput {
  id: ID!
  currentPassword: String!
  newPassword: String!
}

input UserFilter {
  isActive: Boolean
}

extend type Query {
  "Returns a user by id"
  user(id: ID!): User!
  "Returns a list of users"
  users(filter: UserFilter, pagination: PageInput): Users!
  "Returns the currently logged in user"
  currentUser: User
}

extend type Mutation {
  "Activate a user account"
  activateUser(id: ID!): User!
  "Activate multiple user accounts"
  activateUsers(ids: [ID!]!): [User!]!
  "Deactivate a user account"
  deactivateUser(id: ID!): User!
  "Deativate multiple user accounts"
  deactivateUsers(ids: [ID!]!): [User!]!

  "Delete one user"
  deleteUser(id: ID!): ID!
  "Delete multiple users"
  deleteUsers(ids: [ID!]!): [ID!]!
  "Set a user identity as default"
  setDefaultIdentity(userId: ID!, identityId: ID!): User!
  "Update a user's password"
  updatePassword(input: UpdatePasswordInput!): Boolean!
  "Update one user"
  updateUser(id: ID!, input: UpdateUserInput!): User!

  "Login"
  login(input: LoginInput!): LoginResult!
  "Sign up"
  signUp(input: SignUpInput!): ID!
  "Resends the verification email. Meant for use with a token generated by the `verifyEmail` mutation, when the user is not logged in. (eg. if they click on the link with the token but it has expired)"
  resendVerificationEmail(token: String!): Boolean!
  "Resends the verification email. Use this if the user is logged in (but eg. blocked from moving forward until the email is verified)."
  resendVerificationEmailAfterLogin: Boolean!
  "Resets the user's password. Token must have been generated from the `sendPasswordResetEmail` resolver. Password is the new password."
  resetPassword(token: String!, password: String!): Boolean!
  "Sends an email with a password reset link"
  sendPasswordResetEmail(email: String!): Boolean!
  "Sends an email with a token, so that the email can be verified"
  verifyEmail(token: String!): Boolean!
}

extend type Subscription {
  userUpdated(userId: ID!): User!
}
